## Methods

### Numerical Model of the Damped Harmonic Oscillator  

The physical system under investigation is a single‑degree‑of‑freedom mass–spring–damper described by the second‑order ordinary differential equation  

\[
m\ddot{x}(t) + c\dot{x}(t) + k x(t) = 0,
\]

where \(m\) is the mass, \(c\) the viscous damping coefficient, \(k\) the spring constant, \(x(t)\) the displacement, and the dot denotes differentiation with respect to time.  For numerical integration the equation is recast as a first‑order system by introducing the velocity variable \(v(t)=\dot{x}(t)\).  The resulting state vector \(\mathbf{y}(t) = [x(t), v(t)]^{\mathsf{T}}\) satisfies  

\[
\frac{d\mathbf{y}}{dt}= \begin{bmatrix}
v \\[4pt]
-\frac{c}{m}v - \frac{k}{m}x
\end{bmatrix}
\equiv f(t,\mathbf{y};m,c,k).
\]

The function `damped_oscillator` in the source code implements exactly this right‑hand side.  The numerical integration is performed with SciPy’s `solve_ivp`, which by default employs an explicit Dormand–Prince Runge–Kutta method of order 5(4) (often referred to as “RK45”).  This adaptive scheme automatically adjusts the step size to satisfy local error tolerances (default absolute tolerance \(10^{-6}\) and relative tolerance \(10^{-3}\)), providing a balance between accuracy and computational cost without the need for manual step‑size selection.

### Simulation Routine  

The helper routine `simulate` encapsulates the integration call.  It receives the physical parameters \((m,c,k)\), the initial conditions \((x_0,v_0)\), the integration interval `t_span`, and a dense evaluation grid `t_eval`.  Internally it invokes  

```python
sol = solve_ivp(damped_oscillator, t_span, [x0, v0],
                t_eval=t_eval, args=(m, c, k))
```  

and returns the time vector `sol.t` together with the displacement `sol.y[0]` and velocity `sol.y[1]`.  By supplying `t_eval`, the solver interpolates the solution at a fixed set of points, which is essential for producing uniformly sampled plots and for subsequent post‑processing.

### Parameter Selection and Damping Regimes  

The study focuses on three canonical damping regimes defined by the dimensionless damping ratio  

\[
\zeta = \frac{c}{2\sqrt{km}}.
\]

With unit mass (\(m=1\)) and unit spring constant (\(k=1\)), the natural angular frequency is \(\omega_0 = \sqrt{k/m}=1\).  The damping coefficient is therefore computed as  

\[
c = 2\zeta m\omega_0 = 2\zeta.
\]

The chosen ratios are \(\zeta = 0.5\) (underdamped), \(\zeta = 1.0\) (critically damped), and \(\zeta = 2.0\) (overdamped).  These values span the qualitatively distinct response types of the linear oscillator and allow direct visual comparison.

### Temporal Discretisation  

All simulations share a common temporal domain \([0,20]\) s.  The evaluation grid `t_eval` consists of 2000 equally spaced points generated by `np.linspace(0, 20, 2000)`.  This yields a nominal sampling interval of \(\Delta t = 0.01\) s, which is sufficiently fine to resolve the fastest dynamics present in the underdamped case (period \(2\pi/\omega_d \approx 6.28\) s, where \(\omega_d = \omega_0\sqrt{1-\zeta^2}\)).  Because the underlying integrator is adaptive, the actual internal step sizes may be much smaller; the dense output simply interpolates the high‑accuracy solution onto the prescribed grid.

### Plot Generation and Figure Specification  

Two families of figures are produced:

1. **Displacement‑vs‑time plot** – For each damping ratio the displacement trajectory \(x(t)\) is plotted as a continuous line.  Distinct colors (`b`, `g`, `r`) and legend entries identify the regimes.  Axes are labeled “Time (s)” and “Displacement”, a grid is added for readability, and the figure is saved as `displacement_vs_time.png`.

2. **Phase‑space plot** – The state trajectory \((x(t),v(t))\) is visualized using a scatter plot where the point colour encodes simulation time via the `viridis` colormap.  This representation highlights the spiralling or monotonic approach to equilibrium characteristic of each regime.  The plot is saved as `phase_space.png`.

Both figures are generated with Matplotlib, closed after saving to free memory, and no interactive display is invoked, ensuring reproducibility in headless environments.

### Experimental Workflow  

The `main` function orchestrates the entire workflow.  It first defines the physical constants, computes the natural frequency, and constructs the list of damping ratios.  A loop iterates over the three regimes, computes the corresponding damping coefficient, calls `simulate` to obtain the time series, and immediately feeds the results to the plotting routines.  After both figures are written to disk, the script prints a single numeric answer – the natural frequency \(\omega_0\) – in the prescribed format `Answer: <value>`.  No additional metrics (e.g., runtime, error estimates) are recorded because the analytical solution of the linear system is known and the purpose of the script is illustrative rather than quantitative validation.

### Assumptions, Simplifications, and Design Choices  

- **Linear dynamics** – The model assumes a linear viscous damper and Hooke’s law spring; nonlinear effects are deliberately omitted to keep the system analytically tractable.
- **Unit parameters** – Mass and spring constant are fixed at 1.0 kg and 1.0 N/m respectively, which simplifies the expression for \(\omega_0\) and isolates the influence of the damping ratio.
- **Initial conditions** – The oscillator starts from unit displacement with zero initial velocity \((x_0=1, v_0=0)\).  This choice excites the natural mode without introducing additional phase shifts.
- **Deterministic integration** – No stochastic components are present; consequently, a fixed random seed is unnecessary.
- **Solver tolerances** – Default absolute and relative tolerances of `solve_ivp` are retained, providing sufficient accuracy for visual comparison while avoiding the overhead of tighter settings.
- **Visualization resolution** – The scatter size in the phase‑space plot is set to 1 pixel to render a smooth trajectory despite the large number of points (2000 per curve).  The colour map is chosen to convey temporal progression without requiring a separate legend.

### Interaction of Helper Functions and Main Script  

Although the repository contains an empty `helpers.py`, the conceptual design separates concerns as follows: the ODE definition (`damped_oscillator`) and the integration wrapper (`simulate`) act as reusable computational primitives that could be imported by other scripts or notebooks.  The `main` script functions as the experiment driver, handling parameter selection, invoking the primitives, and managing all I/O (figure files and final printed answer).  This modular organization facilitates future extensions, such as adding alternative integrators, performing parameter sweeps over a finer grid of \(\zeta\) values, or computing quantitative error metrics against the known analytical solution.